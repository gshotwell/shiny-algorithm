---
title: "How does Shiny work?"
format: 
  revealjs:
    incremental: true   
filters: 
    - shinylive
---
```{python}
# | echo: false
from helpers import include_shiny_folder


def include_qmd(path):
    with open(path, "r") as file:
        print(file.read())


```

## Searching for a framework
- Data science has a last-mile problem
- You often have to wait for "real web developers" to deliver your solution
    - Expensive!
    - Takes forever!
    - Often incorrect!
- Why can't we do it ourselves?
- Tension between speed an quality
    - Must be quick to develop
    - Don't want to own a product that's hard to maintain

## Example: Feature API
- Developed by data science
- Valuable to the whole company
- Blocked by lack of "real web developer"

## What was missing?
- We needed a framework which used the same model for simple an complicated apps
    - Streamlit's execution model looked fragile
    - Dash's stateless callbacks seemed awkward
    - We didn't have any JavaScript developers

## What is Shiny?
- Framework for building fast extensible applications
- Pure python implementation released last year
- Easy enough to use for rapid prototyping
- Solid enough to use for long term apps

## How did Shiny do that?

```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/ml-example-1",
    components="viewer",
    viewer_height=500,
)
```

## How did Shiny do that?

```{.python}
    @render.plot
    def score_dist():
        df_filtered = df[df["account"] == input.account()]
        return dist_plot(df_filtered)

    @render.plot
    def metric():
        df_filtered = df[df["account"] == input.account()]
        if input.metric() == "ROC Curve":
            return plot_auc_curve(df_filtered, "is_electronics", "training_score")
        else:
            return plot_precision_recall_curve(
                df_filtered, "is_electronics", "training_score"
            )
```

- We told Shiny _what_ to do
- We didn't tell Shiny _when_ to do it

## How do other frameworks work?

- Streamlit: re-render everything everywhere all the time
- Dash/Panel/Gradio: Define callback functions

## Event driven programming

- You have to do it
- Easy to get wrong
- Hard to tell when you've gotten it wrong

## What's a better way?

- Infer the relationships between components 
- Build a computation graph

## Does that really work?

- You're not wrong to find this suspicious
- For this to work, the inference has to be 100% reliable

## How would you do this?

## Static code analysis

```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/todo-list",
    components="viewer",
    viewer_height=500,
)
```

## Runtime tracing
- Watch what components ask for
- Keep track of those relationships
- Use relationships to trigger rendering 


## Outputs and recipes

```{.python code-line-numbers="5"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)

def server(input: Inputs, output: Outputs, session: Session):
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```

## Outputs and recipes

```{.python code-line-numbers="10"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)

def server(input: Inputs, output: Outputs, session: Session):
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```

## Outputs and recipes

```{.python code-line-numbers="11"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)

def server(input: Inputs, output: Outputs, session: Session):
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```

## Recipes and inputs

```{.python code-line-numbers="4"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)


def server(input: Inputs, output: Outputs, session: Session):
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```


## Reactive graph

```{mermaid}
%%| fig-width: 2
flowchart TD
  S[Slider] --> R{Render}
  R --> Sc((Text))
```

## Reactive graph

```{mermaid}
%%| fig-width: 2
flowchart TD
  S[Slider] --> Sc((Text))
```


```{python}
# | output: "asis"
include_qmd("_basic-reactivity.qmd")
```

## Graphs can change
```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/flip-flop",
    components="viewer",
    viewer_height=500,
)
```

```{python}
# | output: "asis"
include_qmd("_flip-flop-app.qmd")
```


## Reactivity scales

- Every Shiny app uses this pattern
- Works for dynamic UIs
- Lazy and efficient

# Reactive calculations

## Saving and reusing calculated values

- So far we've been working with shallow reactive graphs
- Each input is passed to a rendering function which produces an output
- Input -> Recipe -> Output can produce repetitive, inefficient applications
- `@reactive.Calc` creates calculations whose results can be used by one _or more_ outputs
- This adds intermediate nodes to the reactive graph

## Reactive Calc example

```{python}
# | echo: false
# | output: asis
include_shiny_folder("apps/reactivity", components="viewer")
```


## Identify repetition
```{.python code-line-numbers="4,5,11,12"}
    @output
    @render.table
    def df():
        rand = np.random.rand(input.n_rows(), 1)
        df = pd.DataFrame(rand, columns=["col_1"])
        return df

    @output
    @render.plot
    def hist():
        rand = np.random.rand(input.n_rows(), 1)
        df = pd.DataFrame(rand, columns=["col_1"])
        plot = (
            ggplot(df, aes(x="col_1"))
            + geom_histogram(binwidth=0.1, fill="blue", color="black")
            + labs(x="Random Values", y="Frequency", title="Histogram of Random Data")
        )
        return plot
```

## Sample graph

```{mermaid}
%%| fig-width: 4
flowchart TD
  Sl[Slider] --> T[Sample & Table]
  Sl --> P[Sample & Plot]
```

## Problems with repetition

1) Code is in multiple places
2) The app is taking the sample twice
3) The table and graph are not using the same sample!

## Reactive Calculation to the rescue
```{.python code-line-numbers="1-5,10,16"}
    @reactive.Calc
    def sampled_df():
        rand = np.random.rand(input.n_rows(), 1)
        df = pd.DataFrame(rand, columns=["col_1"])
        return df

    @output
    @render.table
    def df():
        return sampled_df()

    @output
    @render.plot
    def hist():
        plot = (
            ggplot(sampled_df(), aes(x="col_1"))
            + geom_histogram(binwidth=0.1, fill="blue", color="black")
            + labs(x="Random Values", y="Frequency", title="Histogram of Random Data")
        )
        return plot
```

## Reactive calculations
- Defined with the `@reactive.Calc` decorator
- Called like other inputs
- Can read inputs, reactive values, or other reactive calculations
- Caches its value, so it's cheap to call repeatedly
- Adds a node to the reactive graph
  - Discards cached value when upstream nodes invalidate
  - Notifies downstream nodes when it invalidates

```{python}
#| output: asis

include_qmd("_reactive-calc.qmd")
```
## Other patterns

- Use `reactive.Effect` for side effects
- Overide reacitivity with `reactive.event`
- Use `reactive.isolate` to prevent cycles
- Include data in reactive graph with `reactive.poll`
- Include time with `reactive.invalidate_later`

## Online workshop


```{python}
import qrcode

qr = qrcode.QRCode(
    version=3, box_size=20, border=10, error_correction=qrcode.constants.ERROR_CORRECT_H
)
data = "https://posit-dev.github.io/shiny-python-workshop-2023/"
qr.add_data(data)
qr.make(fit=True)
img = qr.make_image(fill_color="black", back_color="white")
img.save("qr_code.png")
```

### [https://posit-dev.github.io/shiny-python-workshop-2023/](https://posit-dev.github.io/shiny-python-workshop-2023/)
![](qr_code.png)